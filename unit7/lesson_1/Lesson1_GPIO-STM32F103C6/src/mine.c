// #include "Z:\Program_Files\Freq_used\utilities\Platform_Types.h"
// #include "Z:\Program_Files\Freq_used\utilities\Bit_Math.h"

// // GPIO configrations
// // GpioA
// #define GPIOA_CRL *(vuint32 *)(PORTA_BASE + 0x00)
// #define GPIOA_CRH *(vuint32 *)(PORTA_BASE + 0x04)
// #define GPIOA_ODR *(vuint32 *)(PORTA_BASE + 0x0C)
// #define GPIOA_IDR *(vuint32 *)(PORTA_BASE + 0x08)
// // GpioB
// #define GPIOB_CRL *(vuint32 *)(PORTB_BASE + 0x00)
// #define GPIOB_CRH *(vuint32 *)(PORTB_BASE + 0x04)
// #define GPIOB_ODR *(vuint32 *)(PORTB_BASE + 0x0C)

// // PortA and B bases
// #define PORTA_BASE 0x40010800
// #define PORTB_BASE 0x40010C00
// // clock confifrations
// #define RCC_BASE 0x40021000
// #define RCC_APB2ENR *(vuint32 *)(RCC_BASE + 0x18)
// #define RCC_CFGR *(vuint32 *)(RCC_BASE + 0x04)

// #define delay                         \
//     for (uint32 i = 0; i < 8000; i++) \
//         ;

// void GPIO_init_()
// {
//     // declaring pin 1 to be input mode as floating inputs
//     GPIOA_CRL |= (0b0100 << 4);
//     // declaring pin 13 to be floating inputs
//     GPIOA_CRH |= (0b0100 << 20);
//     // pin 1 in portB  push pull output
//     GPIOB_CRL |= (0b0001 << 4);
//     // declaring pin 13 to be floating inputs
//     GPIOB_CRH |= (0b0001 << 20);
// }
// void Clock_init()
// {
//     // set on the clock for PORTA
//     RCC_APB2ENR |= (1 << 2);
//     // set on the clock for PORTB
//     RCC_APB2ENR |= (1 << 3);
// }

// int main()
// {
//     Clock_init();
//     GPIO_init_();
//     while (1)
//     {
//         int bit_status = READ_BIT(GPIOA_IDR, 1);
//         // PORTA Pin 1 connected to External push up resistor
//         // take action when read 0 from pin
//         if (bit_status == 0)
//         {
//             TOG_BIT(GPIOB_ODR, 1);
//             while (bit_status == 0)
//                 ; // while pressing is still
//         }
//         if (bit_status == 1)
//         {
//             TOG_BIT(GPIOB_ODR, 1);
//         }
//     }
//     delay
//     return 0;
// }
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

typedef volatile unsigned int vuint32_t ;
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#define  GPIOA_BASE				0x40010800
#define  GPIOA_CRH				*(vuint32_t*)(GPIOA_BASE+0x04)
#define  GPIOA_CRL				*(vuint32_t*)(GPIOA_BASE+0x00)
#define  GPIOA_ODR				*(vuint32_t*)(GPIOA_BASE+0x0c)
#define  GPIOA_IDR				*(vuint32_t*)(GPIOA_BASE+0x08)

#define  GPIOB_BASE				0x40010C00
#define  GPIOB_CRH				*(vuint32_t*)(GPIOB_BASE+0x04)
#define  GPIOB_CRL				*(vuint32_t*)(GPIOB_BASE+0x00)
#define  GPIOB_ODR				*(vuint32_t*)(GPIOB_BASE+0x0c)
#define  GPIOB_IDR				*(vuint32_t*)(GPIOB_BASE+0x08)

#define RCC_BASE					0x40021000
#define  RCC_CR						*(vuint32_t*)(RCC_BASE+0x00)
#define  RCC_CFGR					*(vuint32_t*)(RCC_BASE+0x04)
#define  RCC_APP2ENR			*(vuint32_t*)(RCC_BASE+0x18)

void clock_init()
{
	// Enable clock GPIOA
	RCC_APP2ENR |=(1<<2);
	// Enable clock GPIOB
	RCC_APP2ENR |=(1<<3);
}
void gpio_init()
{
	GPIOA_CRL = 0;
	GPIOB_CRL = 0 ;
	GPIOA_ODR = 0 ;
	GPIOA_CRL  &=~(0b11<<4);
	GPIOA_CRL  |=(0b01<<6);

	GPIOB_CRL  &=~(0b11<<6);
	GPIOB_CRL  |=(0b01<<4);
	// PA13 input high Z
	GPIOA_CRH &=~(0b11<<20);
	GPIOA_CRH |=(0b01<<22);

	// PB13 out push pull mode
	GPIOB_CRH  |=(0b01<<20);
	GPIOB_CRH  &=~(0b11<<22);

}
void Delay(int  x)
{
	for (int i=0 ; i<x;i++)
			for (int j=0 ; j<255;j++);
}
int main(void)
{
	clock_init();
	gpio_init();

	while(1)
	{
		if ((( GPIOA_IDR &(1<<1))>>1) == 0)
		{
			GPIOB_ODR	^=1<<1;
			while((( GPIOA_IDR &(1<<1))>>1) == 0);
		}
		if ((( GPIOA_IDR &(1<<13))>>13) == 1)
		{
			GPIOB_ODR	^=1<<13;
		}
		Delay(1);
	}
	return 0;
}
